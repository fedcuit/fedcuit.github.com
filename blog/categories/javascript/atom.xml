<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Feng erdong's Blog]]></title>
  <link href="http://fedcuit.github.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://fedcuit.github.com/"/>
  <updated>2015-06-04T12:04:05+08:00</updated>
  <id>http://fedcuit.github.com/</id>
  <author>
    <name><![CDATA[Feng erdong]]></name>
    <email><![CDATA[fedcuit@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Backbone体验 -- Model篇]]></title>
    <link href="http://fedcuit.github.com/blog/2015/06/04/backbone-model/"/>
    <updated>2015-06-04T08:52:00+08:00</updated>
    <id>http://fedcuit.github.com/blog/2015/06/04/backbone-model</id>
    <content type="html"><![CDATA[<h2>Model</h2>

<p>在<code>Backbone</code>的理念中, 一个<code>Model</code>应该算是存在于客户端的与服器端<code>resource</code>/<code>entity</code>对应的一个JS对象, 定义一个<code>Model</code>很简单:
``` javascript
TodoItem = Backbone.Model.extend({</p>

<pre><code>defaults: {
    title: '',
    completed: false
},
validate: function (attributes) {
  // validation goes here
}
</code></pre>

<p>})
<code>``
创建一个</code>Model<code>的实例就是创建一个对象</code>var todoItem = new TodoItem()<code>, 下面对定义在</code>Model<code>中的常用属性做一下说明(_这些属性其实是一些钩子,</code>Backbone`希望我们去重写这些属性_)</p>

<ul>
<li><p><code>defaults</code></p>

<p>通过这个属性来指定<code>Model</code>的默认值</p>

<p>当创建Model实例的时候没有传入对象来初始化, 那么这个实例的属性就与<code>defaults</code>指定的属性值是一致的, 如:
<code>javascript
var todoItem = new TodoItem();
console.log(JSON.stringify(todoItem.toJSON()));
// {"title":"","completed":false}
</code>
当创建Model实例时传入了对象, 那么这个对象会跟<code>defaults</code>进行merge
<code>javascript
var todoItem = new TodoItem({"newAttr": "valueOfNewAttr", "title": "Build a time machine"});
console.log(JSON.stringify(todoItem.toJSON()));
// {"newAttr":"valueOfNewAttr","title":"Build a time machine","completed":false}
</code></p></li>
<li><p><code>validate</code></p>

<p> 将对<code>Model</code>的验证逻辑放在这个属性对应的方法中, 一般情况下, 我们不会直接调用这个<code>validate</code>方法, 它扮演的角色有点像<code>实现</code>定义在父类中的<code>抽象方法</code>, 这个方法会在<code>Model</code>的其他方法中被用到, 比如以下的这些方法:</p>

<p> <code>isValid()</code></p>

<p> 我们可以调用<code>Model</code>上的<code>isValid()</code>方法来判断这个<code>Model</code>上的属性值满足验证条件</p></li>
</ul>


<p>```javascript
TodoItem = Backbone.Model.extend({
defaults: {</p>

<pre><code>title: '',
completed: false
</code></pre>

<p>},
validate: function (attributes, options) {</p>

<pre><code>if (attributes.title.indexOf("&lt;") != -1) {
    return "html tag is now allowed is title"
}
</code></pre>

<p>}
});
var todoItem = new TodoItem({</p>

<pre><code>"title": "&lt;script&gt;...&lt;/script&gt;"
</code></pre>

<p>});
console.log(todoItem.isValid());
// false
<code>``
  </code>save()<code>or</code>set()`</p>

<p>   默认情况下调用<code>Model</code>的<code>save()</code>方法会触发<code>validate()</code>, 可以通过在<code>save()</code>的时候使用option <code>{validate: false}</code>来跳过验证. 类似的, 也可以在<code>set()</code>时通过option <code>{validate: true}</code>来触发验证.</p>

<p>   <code>validate()</code>方法的返回值比较有趣, 如果验证通过了, 则什么都不用返回, 如果验证失败了, 则需要返回点什么(字符中或是对象都可以).</p>

<p>   <code>validate()</code>方法验证失败之后有两件事件会发生:</p>

<ul>
<li> 将<code>validate()</code>返回的结果添加到<code>Model</code>中, 可以通过<code>model.validationError</code>来访问</li>
<li> 在<code>Model</code>上触发<code>invalid</code>事件, 并像model和error绑定对回调函数上</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Directive - Call controller method in default scope]]></title>
    <link href="http://fedcuit.github.com/blog/2014/06/27/test-directive-call-controller-method-in-default-scope/"/>
    <updated>2014-06-27T14:17:00+08:00</updated>
    <id>http://fedcuit.github.com/blog/2014/06/27/test-directive-call-controller-method-in-default-scope</id>
    <content type="html"><![CDATA[<h2>Call controller method in default scope</h2>

<p>```html</p>

<div ng-controller="FruitController" ng-init="init()">
    <h4>Call controller method in default scope</h4>
    <label>What's your favorite fruit(name can only contains letter)</label>
    <input type="text" ng-model="newFruit"/>
    <button type="button" add-fruit-method>validate and add</button>
    <ul>
        <li ng-repeat="fruit in fruits track by $index"></li>
    </ul>
</div>


<p><code>
This time, we want to validate the fruit name use typed in first, if it only contains letter, then it's eligible to add in, otherwise nothing happen. The validation logic is defined in controller, we need to test the validation method is called inside our directive.
</code>javascript
describe('directives', function () {</p>

<pre><code>beforeEach(module('myApp.directives'));

describe('addFruitMethod', function () {
    var $scope, element;
    beforeEach(inject(function ($rootScope, $compile) {
        $scope = $rootScope;
        $scope.fruits = [];
        $scope.newFruit = 'apple';
        $scope.isValid = angular.noop;

        element = angular.element('&lt;input type="text" name="fruit" id="fruitDefault" ng-model="newFruit"/&gt;&lt;button type="button" add-fruit-method&gt;validate and add&lt;/button&gt;');
        $compile(element)($scope);
    }));

    it('should add valid fruit to fruit list when click button', function () {
        var isValid = spyOn($scope, 'isValid').andReturn(true);

        element.filter('button').trigger('click');

        expect(isValid).toHaveBeenCalled();
        expect($scope.fruits[0]).toBe('apple');

    });

    it('should reject invalid fruit when click button', function () {
        var isValid = spyOn($scope, 'isValid').andReturn(false);

        element.filter('button').trigger('click');

        expect(isValid).toHaveBeenCalled();
        expect($scope.fruits.length).toBe(0);
    });
});
</code></pre>

<p>});
```
It's very similar with testing manipulate data on default scope, the only thing different is we spy on the validation method to verify it has been called, also we let the spy object return the corresponding result to execute each branch.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Directive - Model manipulation with isolated scope]]></title>
    <link href="http://fedcuit.github.com/blog/2014/06/27/test-directive-model-manipulation-with-isolated-scope/"/>
    <updated>2014-06-27T14:15:00+08:00</updated>
    <id>http://fedcuit.github.com/blog/2014/06/27/test-directive-model-manipulation-with-isolated-scope</id>
    <content type="html"><![CDATA[<h2>Model manipulation with isolated scope</h2>

<p>```html</p>

<div ng-controller="FruitController" ng-init="init()">
    <h4>Model manipulation with isolated scope</h4>
    <label>What's your favorite fruit</label>
    <input type="text" ng-model="newFruit"/>
    <button type="button" add-fruit fruits="fruits" new-fruit="newFruit">Add</button>
    <ul>
        <li ng-repeat="fruit in fruits track by $index"></li>
    </ul>
</div>


<p><code>
The above directive manipulate data in default scope, now we create a isolated scope for the directive, the test point change to verify the data on isolated scope.
</code>javascript
describe('directives', function () {</p>

<pre><code>beforeEach(module('myApp.directives'));

describe('addFruit', function () {
    var $scope, element;
    beforeEach(inject(function ($rootScope, $compile) {
        $scope = $rootScope;
        $scope.fruits = [];
        $scope.newFruit = 'apple';
        element = angular.element('&lt;input type="text" ng-model="newFruit"/&gt;&lt;button type="button" add-fruit fruits="fruits" new-fruit="newFruit"&gt;Add&lt;/button&gt;');

        $compile(element)($rootScope);
    }));
    it('should add fruit to fruit list when click button', function () {
        element.filter('button').trigger('click');

        expect(element.scope().fruits[0]).toBe('apple'); // use element.scope() to access isolated scope
        expect($scope.fruits[0]).toBe('apple'); // also verify default scope is updated
    })
});
</code></pre>

<p>});
<code>``
In the test, we setup the surrounding scope, then verify both the default scope and isolated scope are updated.(we use</code>element.scope()` to access the isolated scope).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Directive - Basic Dom Manipulation]]></title>
    <link href="http://fedcuit.github.com/blog/2014/06/27/test-directive-basic-dom-manipulation/"/>
    <updated>2014-06-27T14:08:00+08:00</updated>
    <id>http://fedcuit.github.com/blog/2014/06/27/test-directive-basic-dom-manipulation</id>
    <content type="html"><![CDATA[<h2>Basic Dom Manipulation</h2>

<p>```html</p>

<div>
    <h4>Basic Dom Manipulation</h4>
    <input type="text" name="search" id="search"/>
    <button type="button" clear-search>Clear</button>
</div>


<p><code>``
We're going to write a directive for the button, after click it, the search box wil be clear.
To demonstrate DOM manipulation, we'll not set</code>ngModel` for the search box. Let's write out the test first.</p>

<p>```javascript
describe('directives', function () {</p>

<pre><code>beforeEach(module('myApp.directives'));

describe('clearSearch', function () {
    var $scope, element;
    beforeEach(inject(function ($rootScope, $compile) {
        $scope = $rootScope;
        element = angular.element('&lt;input type="text"/&gt;&lt;button type="button" clear-search&gt;Clear&lt;/button&gt;');

        $compile(element)($scope);
    }));
    it('should clear search box when click clear button', inject(function ($rootScope, $compile) {
        var val = spyOn(jQuery.fn, 'val');
        var prev = spyOn(jQuery.fn, 'prev');

        element.filter('input').val('some value');
        element.filter('button').trigger('click');

        expect(val).toHaveBeenCalled();
        expect(val.mostRecentCall.args[0]).toBe('');
    }));
});
</code></pre>

<p>});
<code>
To be honest, directive which only manipulate DOM doesn't need scope, so we can remove scope in test, the test still can pass.
</code>javascript
describe('directives', function () {</p>

<pre><code>beforeEach(module('myApp.directives'));

describe('clearSearch', function () {
    var element;
    beforeEach(inject(function ($rootScope, $compile) {
        element = angular.element('&lt;input type="text"/&gt;&lt;button type="button" clear-search&gt;Clear&lt;/button&gt;');

        $compile(element)({});
    }));
    it('should clear search box when click clear button', inject(function ($rootScope, $compile) {
        var val = spyOn(jQuery.fn, 'val');
        var prev = spyOn(jQuery.fn, 'prev');

        element.filter('input').val('some value');
        element.filter('button').trigger('click');

        expect(val).toHaveBeenCalled();
        expect(val.mostRecentCall.args[0]).toBe('');
    }));
});
</code></pre>

<p>});
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing With Angular -- Directive]]></title>
    <link href="http://fedcuit.github.com/blog/2014/01/19/testing-with-angular-directives/"/>
    <updated>2014-01-19T21:22:00+08:00</updated>
    <id>http://fedcuit.github.com/blog/2014/01/19/testing-with-angular-directives</id>
    <content type="html"><![CDATA[<p>As a Java developer, I am familiar with test driven development with Java language, but for angular, I'm not, sometime it's even hard to write angular test after the implementation is done.
So I'll write a series of articles about how to test with angular, basically, I'd like to include the test strategy for directives, controllers and services, this article will begin with how to test angular directive.</p>

<p>Let's check out the below examples form easy to hard.</p>

<ul>
<li><a href="/blog/2014/06/27/test-directive-basic-dom-manipulation/">Basic Dom manipulation</a></li>
<li><a href="/blog/2014/06/27/test-directive-model-manipulation-with-default-scope/">Model Manipulation With Default Scope</a></li>
<li><a href="/blog/2014/06/27/test-directive-model-manipulation-with-isolated-scope/">Model Manipulation With Isolated Scope</a></li>
<li><a href="/blog/2014/06/27/test-directive-call-controller-method-in-default-scope/">Call Controller Method in Default Scope</a></li>
<li><a href="/blog/2014/06/27/test-directive-call-controller-method-via-isolated-scope/">Call Controller Method via Isolated Scope</a></li>
</ul>

]]></content>
  </entry>
  
</feed>

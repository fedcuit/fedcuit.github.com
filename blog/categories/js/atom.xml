<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: js | Feng erdong's Blog]]></title>
  <link href="http://fedcuit.github.com/blog/categories/js/atom.xml" rel="self"/>
  <link href="http://fedcuit.github.com/"/>
  <updated>2015-06-10T17:31:14+08:00</updated>
  <id>http://fedcuit.github.com/</id>
  <author>
    <name><![CDATA[Feng erdong]]></name>
    <email><![CDATA[fedcuit@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Call vs Apply vs Bind]]></title>
    <link href="http://fedcuit.github.com/blog/2015/06/10/bind-apply-call/"/>
    <updated>2015-06-10T11:29:00+08:00</updated>
    <id>http://fedcuit.github.com/blog/2015/06/10/bind-apply-call</id>
    <content type="html"><![CDATA[<p>在JavaScript中, 函数是一等公民, 可以作为参数传入另一个函数, 也可以作为函数从另一个返回中返回, 不仅如此, 在JavaScript这门动态语言中, 函数可以被任意对象调用, 比如说<code>function1</code>是定义在<code>obj1</code>上的, 但是它还可以被<code>object2</code>所调用, 怎么做到的? 有下面的三种办法:</p>

<ul>
<li><strong>Call</strong></li>
</ul>


<p>基本语法: <code>fnc.call(thisArg, arg1, arg2... argN)</code></p>

<ul>
<li><code>thisArg</code>将作为<code>this</code>对象传入到函数<code>fnc</code>中</li>
<li><code>arg1, arg2... argN</code>作为参数列表传入到函数中</li>
</ul>


<p>通过<code>call</code>方法可以让一个函数被任何的对象所使用, <code>call()</code>会立即返回使用<code>thisArg</code>作为<code>this</code>对象, 余下部分作为参数列表的调用函数<code>fnc</code>的结果, 如:</p>

<p>```javascript
var person = {
  toString: function(delimiter) {</p>

<pre><code>return "height=" + this.height + delimiter + " weight=" + this.weight;
</code></pre>

<p>  }
};</p>

<p>person.height = "180";
person.weight = "80";</p>

<p>console.log(person.toString(","));
//"height=180, weight=80"</p>

<p>var dog = {};
dog.height = "40";
dog.weight = "30";</p>

<p>console.log(person.toString.call(dog, ":"));
//"height=40: weight=30"
```
* <strong>Apply</strong></p>

<p>上面的例子里<code>toString</code>只是返回了身高与体重的数值, 但是只有数据是没有意义的, 我们还需要单位, 出于演示的目的我们打算将单位传为参数传入<code>toString</code>方法, 修改后的代码如下:
```javascript
var person = {
  toString: function(delimiter, heightUnit, weightUnit) {</p>

<pre><code>return "height=" + this.height + heightUnit + delimiter + " weight=" + this.weight + weightUnit;
</code></pre>

<p>  }
};</p>

<p>person.height = "180";
person.weight = "80";</p>

<p>console.log(person.toString(",", "cm", "kg"));
//"height=180cm, weight=80kg"</p>

<p>var dog = {};
dog.height = "40";
dog.weight = "30";</p>

<p>console.log(person.toString.call(dog, ":", "cm", "kg"));
//"height=40cm: weight=30kg"
<code>
现在在调用`call`的时候需要传入三个参数(除去thisArg),  还不错, 不过接下来我们打算将更进一步, 我们希望在dog对象上添加一个方法`justDoIt`, 不管这个`justDoIt`接收什么参数, 都要将对`justDoIt`函数的调用代码到`toString`方法上去, 先试试看`call`能不能帮我们解决这个问题:
</code>javascript
var person = {
  toString: function(delimiter, heightUnit, weightUnit) {</p>

<pre><code>return "height=" + this.height + heightUnit + delimiter + " weight=" + this.weight + weightUnit;
</code></pre>

<p>  }
};</p>

<p>person.height = "180";
person.weight = "80";</p>

<p>console.log(person.toString(",", "cm", "kg"));
//"height=180cm, weight=80kg"</p>

<p>var dog = {
  justDoIt: function() {</p>

<pre><code>person.toString.call(this, arguments);
</code></pre>

<p>  }
};
dog.height = "40";
dog.weight = "30";</p>

<p>console.log(dog.justDoIt(":", "cm", "kg"));
//"height=40undefined[object Arguments] weight=30undefined"
<code>``
可以看到</code>arguments<code>这个数组被赋值给了第一个参数</code>delimiter<code>, 而</code>heightUnit<code>,</code>weightUnit<code>都没有被正确的赋值, 所以他们都是</code>undefined`.</p>

<p>要解决上面的问题, 就需要<code>apply</code>出场了, <code>apply</code>与<code>call</code>非常的相似, 唯一的区别就是 <code>call</code>需要明确地为每一个参数传值, 而<code>apply</code>只需要一个参数数组就可以了, 当原函数被调用的时候, <code>apply</code>会将这个参数数组<code>unpack</code>并给对应位置上的参数赋值.
```javascript
var person = {
  toString: function(delimiter, heightUnit, weightUnit) {</p>

<pre><code>return "height=" + this.height + heightUnit + delimiter + " weight=" + this.weight + weightUnit;
</code></pre>

<p>  }
};</p>

<p>person.height = "180";
person.weight = "80";</p>

<p>console.log(person.toString(",", "cm", "kg"));
//"height=180cm, weight=80kg"</p>

<p>var dog = {
  justDoIt: function() {</p>

<pre><code>return person.toString.apply(this, arguments);
</code></pre>

<p>  }
};
dog.height = "40";
dog.weight = "30";</p>

<p>console.log(dog.justDoIt(":", "cm", "kg"));
//"height=40cm: weight=30kg"
```
* <strong>Bind</strong></p>

<p>如果你对函数式编程有所了解, 那么你应该知道<code>柯里化(currying function)</code>与<code>偏函数(partial function)</code>, 它们都是有个共同之处就是都是从一个函数上产生出的另一个新的函数.</p>

<p>偏函数可以视为是针对某种情况简化之后的函数, 比如说现在有一个使用函数<code>awesomeFunction(arg1, arg2, arg3)</code>, 而对这个函数的调用过程中, 第一个参数几乎都是相同的, 作为一个眼睛里容不得重复的程序员, 我们应该有一种办法可以消除这种重复, 这个时候偏函数就伴着掌声入场了, 我们在偏函数的声明中已经预置了第一个参数<code>arg1=mostFrequentlyUsedVAlue</code>, 这样我们调用偏参数的时候只需要传入<code>(arg2, arg3</code>)就可以了.</p>

<p>那么现在问题来了, JavaScript将函数视为一等公民, 它作为一门函数式语言, 是怎么实现偏函数的呢.</p>

<p>这时候就需要使用<code>bind</code>了, <code>bind</code>的基本语法与<code>call</code>一致:
<code>fnc.bind(thisArg, arg1, arg2... argN)</code></p>

<p>但是它们有一个重要的区别, 那就是<code>bind</code>不会立即执行原函数, 而是返回一个新的函数, 并且这个新的函数在被调用的时候会自动将已经<code>bind</code>上去的那些参数值赋给对应位置的上的参数, 新的函数只需要关心余下的那部分参数列表.
```javascript
function greet(timeFrame, msg) {
  return "Good " + timeFrame + ", " + msg;
}</p>

<p>console.log(greet("Morning", "What can I do for you?"));
console.log(greet("Morning", "This is your ticket"));
console.log(greet("Morning", "welcome back"));
console.log(greet("Morning", "How was the trip"));
console.log(greet("Afternoon", "Can I borrow you some time?"));
// "Good Morning, What can I do for you?"
// "Good Morning, This is your ticket"
// "Good Morning, welcome back"
// "Good Morning, How was the trip"
// "Good Afternoon, Can I borrow you some time?"
<code>
可以看到`greet`这个函数多数情况下都是使用"Morning"作为第一个参数, 何不创建一个更简短的函数来专门处理这种场景呢:
</code>javascript
function greet(timeFrame, msg) {
  return "Good " + timeFrame + ", " + msg;
}</p>

<p>var morningGreet = greet.bind(undefined, "Morning");</p>

<p>console.log(morningGreet("What can I do for you?"));
console.log(morningGreet("This is your ticket"));
console.log(morningGreet("welcome back"));
console.log(morningGreet("How was the trip"));
console.log(greet("Afternoon", "Can I borrow you some time?"));
```</p>

<p>了解了<code>bind</code>其实是返回一个新的函数之后, 那么其实想通过它来实现上面<code>call</code>/<code>apply</code>的功能其实就非常简单了, 只需要调用一下生成的新的函数就可以了.
```javascript
var person = {
  toString: function(delimiter) {</p>

<pre><code>return "height=" + this.height + delimiter + " weight=" + this.weight;
</code></pre>

<p>  }
};</p>

<p>person.height = "180";
person.weight = "80";</p>

<p>console.log(person.toString(","));
//"height=180, weight=80"</p>

<p>var dog = {};
dog.height = "40";
dog.weight = "30";</p>

<p>console.log(person.toString.bind(dog, ":")());
//"height=40: weight=30"</p>

<h2>```</h2>

<p>上面只是从函数可以被任意对象调用的角度来分析了<code>call</code>, <code>apply</code>, <code>bind</code>的用法, 其实现实使用的过程中, 这些方法还有另一个非常重要的用途, 那就是给回调函数绑定正确的上下文环境(this对象).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backbone体验 -- View篇]]></title>
    <link href="http://fedcuit.github.com/blog/2015/06/04/backbone-view/"/>
    <updated>2015-06-04T12:04:00+08:00</updated>
    <id>http://fedcuit.github.com/blog/2015/06/04/backbone-view</id>
    <content type="html"><![CDATA[<h2>View</h2>

<p>简单讲, <code>View</code>就是用来展示<code>Model</code>里面的数据的.</p>

<p>这样可以简单回顾一下我用过的一些前端JS框架是怎么处理数据展示的, 从最原始的jQuery开始:
只使用jQuery的时候, 当我们已经通过AJAX拿到数据之后, 我们可能需要先定位到需要显示数据的元素然后通过<code>el.val('...')</code>或者<code>el.text('...')</code>将数据手动设置上去. 当元素的值被更新之后需要将修改反应到后端时, 我们可能需要取到所有的元素的最新值然后发送到后台.</p>

<p>如上面那样通过操作对应的单个的DOM元素去设置值的方式写起来很繁琐, 如果返回的数据里面有十几甚至几十个条目的话, 写出来的代码更是毫无美感可言, 于是人们想到了使用JS<code>模板</code>, 通过一段通常是写在<code>&lt;head&gt;&lt;/head&gt;</code>中<code>&lt;script type="text/template" id="myTemplate"&gt;...&lt;/script&gt;</code>来表示最终要后面的HTML的结构, 在其中使用占位符来标识哪里部分需要被真正传入的数据替换. 模板定义好之后, 当拿到AJAX的返回结果时, 我们只需要将数据填充到这个模板, 然后将生成的HTML添加到页面中就可以了, 一句话就可以搞定, 比如 <code>$container.html(_.template($('#myTemplate'), ajaxReponseData))</code>. 比较常用的模板引擎有<code>mustache</code>, <code>underscore template</code></p>

<p>事情发展到这里还没完, 现在数据显示的问题解决的差不多了, 但是如果用户将某些DOM元素的值修改之后, 我们还需要将所有的元素的值读取一遍, 然后将这些值发送到后台去更新这条记录. 我们通过模板技术解决了繁琐的DOM设值, 但是数据的更新还是一个问题.</p>

<p>一起来看看Backbone的<code>View</code>是如何解决这个问题.</p>

<p>首先我们需要定义一个Backbone <code>View</code>, 定义的方法与<code>Model</code>非常的类似, 只需要继承'View`就可以了:
``` javascript
TodoItemView = Backbone.View.extend({</p>

<pre><code>template: _.template($("#todoItemTemplate").html()),
initialize: function () {
    this.render();
},
render: function () {
    return this.$el.html(this.template(this.model.attributes));
},
events: {
    "click .toggle": "handleToggle",
    "click .destroy": "handleDestroy"
},
handleToggle: function () {
    this.model.set('completed', this.$('.toggle').prop('checked'));
}
</code></pre>

<p>}
<code>``
与上面提到的方式不同, Backbone</code>View<code>实现了细粒度的数据更新, 通过对对应的组件进行事件监听, 当某个组件的值被修改时, 只需要将被修改的属性更新到</code>Model`中.</p>

<p>下面介绍一下<code>View</code>中比较重要的几个属性(钩子):</p>

<ul>
<li><p><code>initialize</code></p>

<p>  通常在这个属性对应的方法里面去生成最初的视图, 如上例中所求, 在<code>initialize</code>方法中将模板填充之后添加到<code>View</code>对应的HTML容器中.</p></li>
<li><p><code>el</code></p>

<p>  这个属性通常是一个<em>css selector</em>, 对应页面中这个<code>View</code>将被添加到HTML元素, 可以理解成是这个<code>View</code>的container, 个人理解是在创建Backbone <code>Collection</code>, <code>View</code>, <code>Model</code>的实例的时候, 都可以向其中传入一个对象, 这个对象的属性会与定义时的那些属性进行merge. 所以<code>el</code>既可以声明在<code>View</code>类的定义中, 也可以通过参加传入, 如 <code>var todoItemView = new TodoItemView({el: jQuery('.todoItem'});</code>
  在<code>View</code>内部使用的时候, 通常是通过<code>this.$el</code>来操作这个容器, <code>this.$el</code>将会引用你配置的<code>el</code>对应的jQuery对象.
  除了<code>el</code>之外, 还有一些其他的属性也是跟<code>View</code>的容器相关的:</p>

<ul>
<li><code>tagName</code></li>
<li><code>className</code></li>
</ul>


<p>  如果没有配置<code>View</code>的<code>el</code>属性, 那么默认将使用一个<code>DIV</code>来包装<code>View</code>的内容, 这时候如果配置了<code>tagName</code>, 那么就会使用<code>&lt;tagName&gt;&lt;/tagName&gt;</code>来包装, 如果还有<code>className</code>的话, 那就变成了<code>&lt;tagName class="valueOfClassNameProp"&gt;&lt;/tagName&gt;</code></p></li>
<li><p><code>this.$('css selector')</code></p>

<p>  一开始我也比较疑惑<code>this.$()</code>与<code>$()</code>有什么区别, 看了源码之后才发现原来<code>this.$()</code>是在当时<code>View</code>的范围内查找元素, 是个挺实用的方法.
<code>javascript
$: function(selector) {
return this.$el.find(selector);
},
</code></p></li>
<li><p><code>events</code></p>

<p>  这个属性应该是<code>View</code>所特有的, 它里面定义了一组元素上可能发生的事件以及对应的处理方法, 如:
<code>javascript
events: {
  "click .toggle": "handleToggle",
  "click .destroy": "handleDestroy"
},
handleToggle: function () {
  this.model.set('completed', this.$('.toggle').prop('checked'));
}
</code>
 如在<code>.toggle</code>元素上点击时会执行<code>handleToggle</code>方法. 这种事件监听方式其实与<code>jQuery.on()</code>非常的类似:</p>

<ul>
<li><code>jQuery.on(eventType, selector, handler)</code></li>
<li><code>"eventType selector": "handler"</code></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backbone体验 -- Model篇]]></title>
    <link href="http://fedcuit.github.com/blog/2015/06/04/backbone-model/"/>
    <updated>2015-06-04T08:52:00+08:00</updated>
    <id>http://fedcuit.github.com/blog/2015/06/04/backbone-model</id>
    <content type="html"><![CDATA[<h2>Model</h2>

<p>在<code>Backbone</code>的理念中, 一个<code>Model</code>应该算是存在于客户端的与服器端<code>resource</code>/<code>entity</code>对应的一个JS对象, 定义一个<code>Model</code>很简单:
``` javascript
TodoItem = Backbone.Model.extend({</p>

<pre><code>defaults: {
    title: '',
    completed: false
},
validate: function (attributes) {
  // validation goes here
}
</code></pre>

<p>})
<code>``
创建一个</code>Model<code>的实例就是创建一个对象</code>var todoItem = new TodoItem()<code>, 下面对定义在</code>Model<code>中的常用属性做一下说明(_这些属性其实是一些钩子,</code>Backbone`希望我们去重写这些属性_)</p>

<ul>
<li><p><code>defaults</code></p>

<p>通过这个属性来指定<code>Model</code>的默认值</p>

<p>当创建Model实例的时候没有传入对象来初始化, 那么这个实例的属性就与<code>defaults</code>指定的属性值是一致的, 如:
<code>javascript
var todoItem = new TodoItem();
console.log(JSON.stringify(todoItem.toJSON()));
// {"title":"","completed":false}
</code>
当创建Model实例时传入了对象, 那么这个对象会跟<code>defaults</code>进行merge
<code>javascript
var todoItem = new TodoItem({"newAttr": "valueOfNewAttr", "title": "Build a time machine"});
console.log(JSON.stringify(todoItem.toJSON()));
// {"newAttr":"valueOfNewAttr","title":"Build a time machine","completed":false}
</code></p></li>
<li><p><code>validate</code></p>

<p> 将对<code>Model</code>的验证逻辑放在这个属性对应的方法中, 一般情况下, 我们不会直接调用这个<code>validate</code>方法, 它扮演的角色有点像<code>实现</code>定义在父类中的<code>抽象方法</code>, 这个方法会在<code>Model</code>的其他方法中被用到, 比如以下的这些方法:</p>

<p> <code>isValid()</code></p>

<p> 我们可以调用<code>Model</code>上的<code>isValid()</code>方法来判断这个<code>Model</code>上的属性值满足验证条件</p></li>
</ul>


<p>```javascript
TodoItem = Backbone.Model.extend({
defaults: {</p>

<pre><code>title: '',
completed: false
</code></pre>

<p>},
validate: function (attributes, options) {</p>

<pre><code>if (attributes.title.indexOf("&lt;") != -1) {
    return "html tag is now allowed is title"
}
</code></pre>

<p>}
});
var todoItem = new TodoItem({</p>

<pre><code>"title": "&lt;script&gt;...&lt;/script&gt;"
</code></pre>

<p>});
console.log(todoItem.isValid());
// false
<code>``
  </code>save()<code>or</code>set()`</p>

<p>   默认情况下调用<code>Model</code>的<code>save()</code>方法会触发<code>validate()</code>, 可以通过在<code>save()</code>的时候使用option <code>{validate: false}</code>来跳过验证. 类似的, 也可以在<code>set()</code>时通过option <code>{validate: true}</code>来触发验证.</p>

<p>   <code>validate()</code>方法的返回值比较有趣, 如果验证通过了, 则什么都不用返回, 如果验证失败了, 则需要返回点什么(字符中或是对象都可以).</p>

<p>   <code>validate()</code>方法验证失败之后有两件事件会发生:</p>

<ul>
<li> 将<code>validate()</code>返回的结果添加到<code>Model</code>中, 可以通过<code>model.validationError</code>来访问</li>
<li> 在<code>Model</code>上触发<code>invalid</code>事件, 并像model和error绑定对回调函数上</li>
</ul>

]]></content>
  </entry>
  
</feed>
